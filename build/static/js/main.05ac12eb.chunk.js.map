{"version":3,"sources":["components/fileupload/fileupload.jsx","components/gallery/galleryimage.jsx","components/modal/modal.jsx","components/gallery/gallery.jsx","App.js","serviceWorker.js","index.js"],"names":["FileUploadInput","props","handleFileSelect","bind","state","message","e","console","log","target","files","data","FormData","fileIndex","length","append","name","fetch","this","baseURL","then","response","json","fileUploadResponseCallback","currentFiles","type","onChange","multiple","React","Component","className","style","url","onClick","handleImageClick","showModal","children","Array","isArray","visibility","closeModal","Gallery","showImageInModal","modalContents","setState","Fragment","images","map","imageURL","index","key","App","updateImages","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.05ac12eb.chunk.js","sourcesContent":["import React from 'react';\n\nclass FileUploadInput extends React.Component{\n    constructor(props){\n        super(props);\n        this.handleFileSelect = this.handleFileSelect.bind( this );\n        this.state = {\n            message:''\n        }\n    }\n    handleFileSelect(e){\n        console.log(e.target.files);\n        const data = new FormData();\n        const files = e.target.files;\n        for( var fileIndex = 0; fileIndex <= files.length-1; fileIndex++){\n            data.append( files[ fileIndex ].name, files[ fileIndex ]);\n        }\n        fetch( this.props.baseURL + 'uploadendpoint.php',{\n            'method': 'POST',\n            'body': data\n        })\n            .then( response => response.json())\n            .then( (response)=>{\n                this.props.fileUploadResponseCallback( response.currentFiles );\n            })\n    }\n    render(){\n        return (\n        <input type=\"file\" onChange={this.handleFileSelect} multiple/>\n        )\n    }\n}\n\nexport default FileUploadInput;","import React from 'react';\n\nexport default props => {\n    const clickHandler = ()=>{\n        if(props.handleImageClick){\n            props.handleImageClick(props.url)\n        }\n    }\n    return (<div className=\"item\" style={{'backgroundImage':`url('${props.url}')`}} onClick={clickHandler}></div>);\n}\n","import React from 'react';\nimport './modal.css';\n\nexport default (props)=>{\n    //debugger;\n    let showModal = false;\n    if( props.children ){\n        if(Array.isArray(props.children)){\n            if(props.children.length){\n                showModal = true;\n            }\n            \n        } else {\n            showModal = true;\n        }\n    }\n    return (\n    <div className=\"modalShadow\" style={{ visibility: showModal ? 'visible' : 'hidden'}}>\n        <div className=\"modalBody\">\n            <div className=\"modalClose\" onClick={props.closeModal}>X</div>\n            <div className=\"modalContent\">\n                {props.children}\n            </div>\n        </div>\n    </div>\n    );\n}","import React from 'react';\nimport ImageGallery from './galleryimage.jsx';\nimport './gallery.css';\nimport Modal from '../modal/modal';\n\nclass Gallery extends React.Component{\n    constructor(props){\n        super(props);\n        this.showImageInModal = this.showImageInModal.bind( this );\n        this.closeModal = this.closeModal.bind(this);\n        this.state = {\n            modalContents : null\n        }\n    }\n    showImageInModal(url){\n        this.setState({\n            modalContents: <ImageGallery url={url}  />\n        })\n    }\n    closeModal(){\n        this.setState({\n            modalContents: null\n        })\n    }\n    render(){\n        return (\n            <React.Fragment>\n                <div className=\"imageGallery\">\n                    {this.props.images.map((imageURL, index)=>{\n                        return (<ImageGallery url={`${this.props.baseURL}/${imageURL}`} handleImageClick={this.showImageInModal} key={imageURL+index} />);\n                    })}\n                </div>\n                <Modal closeModal={this.closeModal}>\n                    {this.state.modalContents}\n                </Modal>\n            </React.Fragment>\n        );\n    }\n\n}\n\nexport default Gallery\n\n","import React from 'react';\nimport './App.css';\nimport FileUploadInput from './components/fileupload/fileupload';\nimport Gallery from './components/gallery/gallery';\n\nclass App extends React.Component{\n  constructor(props){\n    super(props);\n    this.updateImages = this.updateImages.bind(this);\n    this.state = {\n      images: [],\n      baseURL: 'http://localhost/lfz/_practice/reactfileupload/public/server/'\n    }\n  }\n  componentDidMount(){\n    fetch( this.state.baseURL + 'uploadendpoint.php',{\n      'method': 'POST'\n    })\n      .then( response => response.json())\n      .then( (response)=>{\n        this.setState({\n          images: response.currentFiles\n        })\n      })\n  }\n  updateImages( images ){\n    debugger;\n    this.setState({\n      images\n    });\n  }\n  render(){\n    return(\n      <div className=\"App\">\n        <FileUploadInput baseURL={this.state.baseURL} fileUploadResponseCallback={this.updateImages}/>\n        <Gallery baseURL={this.state.baseURL} images={this.state.images} />\n      </div>\n      \n    );\n    \n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}